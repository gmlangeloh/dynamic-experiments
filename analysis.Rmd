---
title: "Evaluating dynamic Gröbner Basis algorithms"
author: "Gabriel Mattos Langeloh"
date: "10/10/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

dyn_results <- read.table("basic_data.out", header=T)
```

In this document, I will analyze some results of dynamic Gröbner Basis algorithms. The following algorithms and instances were used to generate the data.

```{r}
"Instances"
unique(dyn_results$instance)
"Algorithms"
unique(dyn_results$algorithm)
```

```{r}
by_instance <- dyn_results %>% group_by(instance)
by_algorithm <- dyn_results %>% group_by(algorithm)
by_inst_alg <- dyn_results %>% group_by(instance, algorithm)
```

First, we want to visualize the running time of the algorithms per instance, comparatively, and to find the algorithm that runs the fastest for each instance.

```{r}
ggplot(by_inst_alg, aes(x=instance, y=time, fill=algorithm)) + 
  geom_col(position='dodge') + 
  coord_flip()
fastest <- by_instance %>% 
  filter(rank(time) == 1) %>% 
  select(instance, algorithm)
slowest <- by_instance %>% 
  filter(rank(desc(time)) == 1) %>% 
  select(instance, algorithm)
print(fastest)
print(slowest)
```

We observe that static is the fastest algorithm on most instances, and caboara-perry is slowest on most.

Now, we compare the sizes of the output bases, in number of polynomials.

```{r}
ggplot(by_inst_alg, aes(x=instance, y=polynomials, fill=algorithm)) + 
  geom_col(position='dodge') + 
  coord_flip()
smallest <- by_instance %>% 
  filter(rank(time) == 1) %>% 
  select(instance, algorithm)
largest <- by_instance %>% 
  filter(rank(desc(time)) == 1) %>% 
  select(instance, algorithm)
print(smallest)
print(largest)
```

Here, the dynamic algorithms (perturbation and caboara-perry) get better results than static for larger instances, such as cyclicn6 and cyclicnh6. All algorithms tie or are close to tying for the katsura family. It can be shown that the affine Katsura instance with parameter $n$ has a Gröbner Basis with $n$ polynomials. All three algorithms are far from this lower bound, which means the dynamic algorithms should be improved to deal with this kind of situation better.